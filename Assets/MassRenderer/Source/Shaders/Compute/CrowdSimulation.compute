#pragma kernel CSMain

#define SIMULATION_BLOCK_SIZE 128

#include "Assets/MassRenderer/Source/Shaders/Common/MatrixUtils.hlsl"

int _InstanceCount;
float4 _BoundCenter;
float4 _BoundSize;
float _DeltaTime;

struct AgentData 
{
    float3 position;
    float3 direction;
    float3 scale;
    float speed; 
};

struct InstanceData
{
    int    meshIndex; 
    int    textureSkinIndex;
    int    animationIndex;
    float  animationSpeed;
    float4x4 tsr;
}; 

RWStructuredBuffer<AgentData> _AgentDataBufferWrite;
RWStructuredBuffer<InstanceData> _InstanceDataBufferWrite;

float3 WrapPosition(float3 position)
{
    float3 pos = position;
    float3 center = _BoundCenter.xyz;
    float3 bounds = _BoundSize.xyz;

    float3 min = center - bounds * 0.5;
    float3 max = center + bounds * 0.5;

    pos.x = pos.x < min.x ? float3(center + bounds * 0.5).x : pos.x;
    pos.x = pos.x > max.x ? float3(center - bounds * 0.5).x : pos.x;

    pos.z = pos.z < min.z ? float3(center + bounds * 0.5).z : pos.z;
    pos.z = pos.z > max.z ? float3(center - bounds * 0.5).z : pos.z;

    return pos;
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void CSMain (uint3 DTid : SV_DispatchThreadID, uint3 Gid : SV_GroupID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    const unsigned int index = DTid.x;
    
    AgentData agnet = _AgentDataBufferWrite[index];
    InstanceData instance = _InstanceDataBufferWrite[index];

    float3 displacement = normalize(agnet.direction) * agnet.speed * _DeltaTime;

    agnet.position += displacement;  
    agnet.position = WrapPosition(agnet.position);

    instance.tsr = BuildTRS(agnet.position, agnet.direction, agnet.scale);

    _AgentDataBufferWrite[index] = agnet;    
    _InstanceDataBufferWrite[index] = instance; 
}